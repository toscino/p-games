<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect 4</title>

    <!-- All CSS goes inside this <style> tag -->
    <style>
        /* Basic page styling */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f7ff;
            color: #333;
            padding: 1rem;
            box-sizing: border-box;
        }

        h1 {
            color: #005a8f;
            margin-top: 0;
        }

        /* Status message (whose turn, who won) */
        #status {
            font-size: 1.5rem;
            font-weight: bold;
            height: 2rem; /* Reserve space to prevent layout shift */
            margin-bottom: 1rem;
        }

        /* The game board grid */
        #board {
            display: grid;
            /* 6 rows, 7 columns */
            /* We use calc() to make it responsive on smaller screens */
            grid-template-rows: repeat(6, max(40px, min(80px, 10vw)));
            grid-template-columns: repeat(7, max(40px, min(80px, 10vw)));
            
            /* This is the classic "blue" board color */
            background-color: #0077be; 
            
            border: 10px solid #005a8f;
            border-radius: 10px;
            padding: 10px;
            gap: 10px; /* This creates the space between the holes */
        }

        /* The individual cells/holes */
        .cell {
            width: 100%;
            height: 100%;
            
            /* This makes the empty holes white */
            background-color: #ffffff; 
            border-radius: 50%; /* Makes them circles */
            cursor: pointer;
            transition: background-color 0.2s;
        }

        /* Style for a cell taken by Player 1 (Red) */
        .cell.player1 {
            background-color: #d90429;
            box-shadow: inset 0 -4px 8px rgba(0,0,0,0.2);
        }

        /* Style for a cell taken by Player 2 (Yellow) */
        .cell.player2 {
            background-color: #ffde00;
            box-shadow: inset 0 -4px 8px rgba(0,0,0,0.2);
        }

        /* Button styling */
        #resetButton {
            margin-top: 20px;
            padding: 12px 25px;
            font-size: 1em;
            font-weight: bold;
            color: white;
            background-color: #0077be;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #resetButton:hover {
            background-color: #005a8f;
        }

        /* Style to show when the board is not clickable (AI's turn) */
        #board.disabled {
            cursor: not-allowed;
        }
    </style>
</head>

<body>

    <h1>Connect 4 vs. AI</h1>
    
    <!-- This h2 will show whose turn it is or who won -->
    <h2 id="status">Your Turn (Red)</h2>
    
    <!-- The game board will be generated by JavaScript inside this div -->
    <div id="board"></div>
    
    <button id="resetButton">Reset Game</button>

    <!-- All JavaScript goes inside this <script> tag -->
    <script>
        // Wait for the DOM to be fully loaded before running the game script
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- Constants ---
            const ROWS = 6;
            const COLS = 7;
            const PLAYER_1 = 'player1'; // Human
            const PLAYER_2 = 'player2'; // AI

            // --- Game State Variables ---
            let board = []; // 2D array to track game state
            let currentPlayer = PLAYER_1;
            let gameOver = false;

            // --- DOM Elements ---
            const boardElement = document.getElementById('board');
            const statusElement = document.getElementById('status');
            const resetButton = document.getElementById('resetButton');

            // --- Functions ---

            /**
             * Creates the 2D array for the game logic and
             * creates the HTML elements for the board UI.
             */
            function createBoard() {
                board = []; // Reset the internal board state
                boardElement.innerHTML = ''; // Clear the visual board
                
                for (let r = 0; r < ROWS; r++) {
                    const row = [];
                    for (let c = 0; c < COLS; c++) {
                        // Logic board
                        row.push(null); // null means empty
                        
                        // Visual board
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        
                        // Use data-attributes to know which cell was clicked
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        
                        cell.addEventListener('click', handleCellClick);
                        boardElement.appendChild(cell);
                    }
                    board.push(row);
                }
            }

            /**
             * Handles what happens when a HUMAN player clicks on a cell.
             */
            function handleCellClick(event) {
                // Ignore clicks if game is over or it's not the human's turn
                if (gameOver || currentPlayer !== PLAYER_1) return;

                const col = parseInt(event.target.dataset.col);
                
                const r = getNextOpenRow(col);
                
                // Check if the column is full
                if (r === -1) {
                    return; // Column is full, do nothing
                }
                
                // 1. Place the human's piece
                dropPiece(r, col, PLAYER_1);

                // 2. Check for a human win
                if (checkWin(r, col)) {
                    gameOver = true;
                    statusElement.textContent = "You Win! (Red)";
                    return;
                }
                
                // 3. Check for a draw
                if (checkDraw()) {
                    gameOver = true;
                    statusElement.textContent = "It's a Draw!";
                    return;
                }

                // 4. Switch to the AI's turn
                switchPlayer();
                statusElement.textContent = "AI is thinking...";
                boardElement.classList.add('disabled'); // Disable board clicks

                // Call the AI move after a short delay
                setTimeout(makeAIMove, 500);
            }

            /**
             * Contains the logic for the AI's move.
             */
            function makeAIMove() {
                if (gameOver) return;

                // 1. Check for an immediate winning move for the AI
                let aiMove = findWinningMove(PLAYER_2);
                
                // 2. Check for an immediate winning move for the Human (and block it)
                if (aiMove === null) {
                    aiMove = findWinningMove(PLAYER_1);
                }
                
                // 3. If no wins/blocks, pick a random valid column
                if (aiMove === null) {
                    aiMove = findRandomValidMove();
                }

                // Failsafe in case board is full (should be caught by checkDraw)
                if (aiMove === null) {
                    return;
                }

                const r = getNextOpenRow(aiMove);
                if (r === -1) return; // Should not happen if logic is correct

                // Place the AI's piece
                dropPiece(r, aiMove, PLAYER_2);

                // Check for AI win
                if (checkWin(r, aiMove)) {
                    gameOver = true;
                    statusElement.textContent = "AI Wins! (Yellow)";
                    return;
                }

                // Check for draw (can happen on AI's last move)
                if (checkDraw()) {
                    gameOver = true;
                    statusElement.textContent = "It's a Draw!";
                    return;
                }

                // Switch back to the human player
                switchPlayer();
                statusElement.textContent = "Your Turn (Red)";
                boardElement.classList.remove('disabled'); // Re-enable board
            }

            /**
             * Helper function to find the next available (empty) row in a given column.
             * Returns -1 if the column is full.
             */
            function getNextOpenRow(col) {
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (board[r][col] === null) {
                        return r; // Found empty spot
                    }
                }
                return -1; // Column is full
            }

            /**
             * Helper function to physically place a piece on the board (logic + visual).
             */
            function dropPiece(r, col, player) {
                // Update logic board
                board[r][col] = player;
                
                // Update visual board
                const cell = document.querySelector(`[data-row='${r}'][data-col='${col}']`);
                cell.classList.add(player);
            }

            /**
             * Switches the currentPlayer variable.
             */
            function switchPlayer() {
                currentPlayer = (currentPlayer === PLAYER_1) ? PLAYER_2 : PLAYER_1;
            }

            /**
             * AI LOGIC: Checks all columns to see if 'player' has a winning move.
             * Returns the column number if a win is found, otherwise null.
             */
            function findWinningMove(player) {
                for (let c = 0; c < COLS; c++) {
                    const r = getNextOpenRow(c);
                    
                    // If column is not full
                    if (r !== -1) {
                        // "Pretend" to make the move
                        board[r][c] = player;
                        
                        const isWinningMove = checkWin(r, c);
                        
                        // "Undo" the pretend move
                        board[r][c] = null;

                        if (isWinningMove) {
                            return c; // Found a winning column
                        }
                    }
                }
                return null; // No winning move found
            }

            /**
             * AI LOGIC: Finds a random valid column that is not full.
             */
            function findRandomValidMove() {
                let validCols = [];
                for (let c = 0; c < COLS; c++) {
                    if (board[0][c] === null) { // Check top row
                        validCols.push(c);
                    }
                }
                
                if (validCols.length > 0) {
                    const randIndex = Math.floor(Math.random() * validCols.length);
                    return validCols[randIndex];
                }
                
                return null; // No valid moves left (board is full)
            }


            /**
             * Checks for a 4-in-a-row starting from the last piece placed.
             */
            function checkWin(r, c) {
                // We need to get the player from the board, not from the global state
                const player = board[r][c];
                if (!player) return false; // Cell is empty

                // A simpler, more readable win-check
                const checkDirection = (dr, dc) => {
                    let count = 0;
                    for(let i = 1; i < 4; i++) { // Check 3 spots in one direction
                        const newR = r + i * dr;
                        const newC = c + i * dc;
                        if(newR < 0 || newR >= ROWS || newC < 0 || newC >= COLS || board[newR][newC] !== player) break;
                        count++;
                    }
                    return count;
                }

                const checkAllDirections = () => {
                    // Check horizontal (left + right)
                    if (checkDirection(0, -1) + checkDirection(0, 1) >= 3) return true;
                    // Check vertical (down)
                    // Note: We only need to check downwards (1, 0)
                    if (checkDirection(1, 0) >= 3) return true;
                    // Check diagonal (down-left + up-right)
                    if (checkDirection(1, -1) + checkDirection(-1, 1) >= 3) return true;
                    // Check diagonal (down-right + up-left)
                    if (checkDirection(1, 1) + checkDirection(-1, -1) >= 3) return true;

                    return false;
                }

                return checkAllDirections();
            }

            /**
             * Checks if the board is full (no null values).
             */
            function checkDraw() {
                // Check the top row. If it's full, the board is full.
                for (let c = 0; c < COLS; c++) {
                    if (board[0][c] === null) {
                        return false; // Found an empty cell, not a draw
                    }
                }
                return true; // No empty cells in the top row, it's a draw
            }

            /**
             * Resets the game to its initial state.
             */
            function resetGame() {
                gameOver = false;
                currentPlayer = PLAYER_1;
                statusElement.textContent = "Your Turn (Red)";
                boardElement.classList.remove('disabled');
                createBoard();
            }

            // --- Event Listeners ---
            resetButton.addEventListener('click', resetGame);

            // --- Game Initialization ---
            createBoard(); // Create the board when the page loads
        
        }); // End of DOMContentLoaded
    </script>
</body>
</html>